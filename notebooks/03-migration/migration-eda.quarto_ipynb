{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: Mapping migration\n",
        "subtitle: Introduction to vector data operations\n",
        "learning-goals:\n",
        "- Combine different types of vector data with spatial joins\n",
        "- Create a chloropleth plot\n",
        "jupyter: python3\n",
        "format:\n",
        "  html: default\n",
        "params:\n",
        "  id: eda\n",
        "  species_name: Veery Thrush\n",
        "  species_lookup: catharus fuscescens\n",
        "  sample_filename: migration-foundations-data\n",
        "  download_filename: gbif_veery\n",
        "  plot_filename: veery_migration\n",
        "---\n",
        "\n",
        "\n",
        "\n",
        "The Veery thrush (Catharus fuscescens) migrates each year between nesting sites in the U.S. and Canada, and South America. Veeries are small birds, and encountering a hurricane during their migration would be disasterous. However, Ornithologist Christopher Hechscher has found in tracking their migration that their breeding patterns and migration timing can predicting the severity of hurricane season as accurately as meterological models [@heckscher_nearctic-neotropical_2018]!\n",
        "\n",
        "![Veery in Central Park by the Ramble Stone Arch. Source: [Wikimedia](https://commons.wikimedia.org/wiki/File:Veery_in_CP_(43277).jpg)](https://upload.wikimedia.org/wikipedia/commons/e/e8/Veery_in_CP_%2843277%29.jpg)\n",
        "\n",
        "::: {.callout-read}\n",
        "You can read more about the Veery migration and how climate change may be impacting these birds in [this article from the Audobon Society](https://www.audubon.org/news/are-these-birds-better-computers-predicting-hurricane-seasons), or in Heckscher's [open access report](https://www.nature.com/articles/s41598-018-28302-3).\n",
        ":::\n",
        "\n",
        ":::{.callout-video}\n",
        ":::: {.panel-tabset}\n",
        "\n",
        "### Prepare Data\n",
        "\n",
        "<div style=\"position: relative; width: 100%; height: 0; padding-top: 56.2500%;\n",
        " padding-bottom: 0; box-shadow: 0 2px 8px 0 rgba(63,69,81,0.16); margin-top: 1.6em; margin-bottom: 0.9em; overflow: hidden;\n",
        " border-radius: 8px; will-change: transform;\">\n",
        "  <iframe loading=\"lazy\" style=\"position: absolute; width: 100%; height: 100%; top: 0; left: 0; border: none; padding: 0;margin: 0;\"\n",
        "    src=\"https://www.canva.com/design/DAGSQQsQ_PA/u2M01H6IMkbCRryW2A7_yQ/watch?embed\" allowfullscreen=\"allowfullscreen\" allow=\"fullscreen\">\n",
        "  </iframe>\n",
        "</div>\n",
        "<a href=\"https:&#x2F;&#x2F;www.canva.com&#x2F;design&#x2F;DAGSQQsQ_PA&#x2F;u2M01H6IMkbCRryW2A7_yQ&#x2F;watch?utm_content=DAGSQQsQ_PA&amp;utm_campaign=designshare&amp;utm_medium=embeds&amp;utm_source=link\" target=\"_blank\" rel=\"noopener\">DEMO: Migration Part 1 (EDA)</a> by Earth Lab\n",
        "\n",
        "\n",
        "### Dynamic Plot\n",
        "\n",
        "<div style=\"position: relative; width: 100%; height: 0; padding-top: 56.2500%;\n",
        " padding-bottom: 0; box-shadow: 0 2px 8px 0 rgba(63,69,81,0.16); margin-top: 1.6em; margin-bottom: 0.9em; overflow: hidden;\n",
        " border-radius: 8px; will-change: transform;\">\n",
        "  <iframe loading=\"lazy\" style=\"position: absolute; width: 100%; height: 100%; top: 0; left: 0; border: none; padding: 0;margin: 0;\"\n",
        "    src=\"https://www.canva.com/design/DAGSihQhE1E/pEr21iwZyKFm51eyZcT5wg/watch?embed\" allowfullscreen=\"allowfullscreen\" allow=\"fullscreen\">\n",
        "  </iframe>\n",
        "</div>\n",
        "<a href=\"https:&#x2F;&#x2F;www.canva.com&#x2F;design&#x2F;DAGSihQhE1E&#x2F;pEr21iwZyKFm51eyZcT5wg&#x2F;watch?utm_content=DAGSihQhE1E&amp;utm_campaign=designshare&amp;utm_medium=embeds&amp;utm_source=link\" target=\"_blank\" rel=\"noopener\">DEMO: Migration Part 2 (EDA)</a> by Earth Lab\n",
        "\n",
        "### Portfolio Post\n",
        "\n",
        "<div style=\"position: relative; width: 100%; height: 0; padding-top: 56.2500%;\n",
        " padding-bottom: 0; box-shadow: 0 2px 8px 0 rgba(63,69,81,0.16); margin-top: 1.6em; margin-bottom: 0.9em; overflow: hidden;\n",
        " border-radius: 8px; will-change: transform;\">\n",
        "  <iframe loading=\"lazy\" style=\"position: absolute; width: 100%; height: 100%; top: 0; left: 0; border: none; padding: 0;margin: 0;\"\n",
        "    src=\"https://www.canva.com/design/DAGTHFtabF0/2Gd9koO6O9p2RL41fJuA1g/watch?embed\" allowfullscreen=\"allowfullscreen\" allow=\"fullscreen\">\n",
        "  </iframe>\n",
        "</div>\n",
        "<a href=\"https:&#x2F;&#x2F;www.canva.com&#x2F;design&#x2F;DAGTHFtabF0&#x2F;2Gd9koO6O9p2RL41fJuA1g&#x2F;watch?utm_content=DAGTHFtabF0&amp;utm_campaign=designshare&amp;utm_medium=embeds&amp;utm_source=link\" target=\"_blank\" rel=\"noopener\">DEMO: Migration Part 3 (EDA)</a> by Earth Lab\n",
        "\n",
        "::::\n",
        ":::\n",
        "\n",
        "\n",
        "::: {.callout-respond title=\"What can we learn from migration patterns?\"}\n",
        "Reflect on what you know about migration. You could consider:\n",
        "\n",
        "  1. What are some reasons that animals migrate?\n",
        "  2. How might climate change affect animal migrations?\n",
        "  3. Do you notice any animal migrations in your area?\n",
        "  \n",
        ":::\n",
        "\n",
        "::: {.content-visible when-format=\"ipynb\"}\n",
        ":::: {.cell .markdown}\n",
        "YOUR ANSWER HERE\n",
        "::::\n",
        ":::\n",
        "\n",
        "\n",
        "## STEP 1: Set up your reproducible workflow\n",
        "\n",
        "### Import Python libraries\n",
        "\n",
        "::: {.callout-task title=\"Import packages\"}\n",
        "\n",
        "In the imports cell, we've included some packages that you will need. Add imports for packages that will help you:\n",
        "\n",
        "1.  Work with tabular data\n",
        "2.  Work with geospatial vector data\n",
        "\n",
        ":::\n"
      ],
      "id": "13c27019"
    },
    {
      "cell_type": "code",
      "metadata": {
        "class": "student-code",
        "highlight": true
      },
      "source": [
        "#| echo: true\n",
        "#| eval: false\n",
        "import os\n",
        "import pathlib"
      ],
      "id": "6857510c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.content-visible when-format=\"html\"}\n"
      ],
      "id": "938969ad"
    },
    {
      "cell_type": "code",
      "metadata": {
        "class": "answer-code",
        "highlight": true
      },
      "source": [
        "#| echo: true\n",
        "#| eval: true\n",
        "#| code-fold: true\n",
        "#| code-summary: See our solution!\n",
        "import os\n",
        "import pathlib\n",
        "\n",
        "import geopandas as gpd\n",
        "import pandas as pd"
      ],
      "id": "6f807547",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "### Create a folder for your data\n",
        "\n",
        "For this challenge, you will need to save some data to the computer you're working on. We suggest saving to somewhere in your *home* folder (e.g. `/home/username`), rather than to your GitHub repository, since data files can easily become too large for GitHub.\n",
        "\n",
        "::: callout-warning\n",
        "The **home** directory is different for every user! Your home directory probably won't exist on someone else's computer. Make sure to use code like `pathlib.Path.home()` to compute the home directory on the computer the code is running on. This is key to writing reproducible and interoperable code.\n",
        ":::\n",
        "\n",
        "::: {.callout-task title=\"Create a project folder\"}\n",
        "\n",
        "The code below will help you get started with making a project directory\n",
        "\n",
        "1.  Replace `'your-project-directory-name-here'` and `'your-gbif-data-directory-name-here'` with **descriptive** names\n",
        "2.  Run the cell\n",
        "3.  (OPTIONAL) Check in the terminal that you created the directory using the command `ls ~/earth-analytics/data`\n",
        ":::\n"
      ],
      "id": "e73c3d71"
    },
    {
      "cell_type": "code",
      "metadata": {
        "class": "student-code",
        "highlight": true
      },
      "source": [
        "#| echo: true\n",
        "#| eval: false\n",
        "# Create data directory in the home folder\n",
        "data_dir = os.path.join(\n",
        "    # Home directory\n",
        "    pathlib.Path.home(),\n",
        "    # Earth analytics data directory\n",
        "    'earth-analytics',\n",
        "    'data',\n",
        "    # Project directory\n",
        "    'your-project-directory-name-here',\n",
        ")\n",
        "os.makedirs(data_dir, exist_ok=True)"
      ],
      "id": "08b7f4d0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.content-visible when-format=\"html\"}\n"
      ],
      "id": "54ce7b87"
    },
    {
      "cell_type": "code",
      "metadata": {
        "class": "answer-code",
        "highlight": true
      },
      "source": [
        "#| echo: true\n",
        "#| eval: true\n",
        "#| code-fold: true\n",
        "#| code-summary: See our solution!\n",
        "# Create data directory in the home folder\n",
        "data_dir = os.path.join(\n",
        "    pathlib.Path.home(),\n",
        "    'earth-analytics',\n",
        "    'data',\n",
        "    'migration',\n",
        ")\n",
        "os.makedirs(data_dir, exist_ok=True)"
      ],
      "id": "c8d70b65",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "## STEP 2: Define your study area -- the ecoregions of North America\n",
        "\n",
        "Track observations of __param_species_name across different **ecoregions**! You should be able to see changes in the number of observations in each ecoregion throughout the year.\n",
        "\n",
        "::: {.callout-read}\n",
        "The ecoregion data will be available as a **shapefile**. Learn more about shapefiles and vector data in this [Introduction to Spatial Vector Data File Formats in Open Source Python](https://www.earthdatascience.org/courses/intro-to-earth-data-science/file-formats/use-spatial-data/use-vector-data/)\n",
        ":::\n",
        "\n",
        "### Download and save ecoregion boundaries\n",
        "\n",
        "The ecoregion boundaries take some time to download -- they come in at about 150MB. To use your time most efficiently, we recommend **caching** the ecoregions data on the machine you're working on so that you only have to download once. To do that, we'll also introduce the concept of **conditionals**, or code that adjusts what it does based on the situation.\n",
        "\n",
        "::: {.callout-read}\n",
        "Read more about conditionals in this [Intro Conditional Statements in Python](https://www.earthdatascience.org/courses/intro-to-earth-data-science/write-efficient-python-code/conditional-statements/)\n",
        ":::\n",
        "\n",
        "::: {.callout-task title=\"Get ecoregions boundaries\"}\n",
        "\n",
        "1.  Find the URL for for the ecoregion boundary **Shapefile**. You can [get ecoregion boundaries from Google.](https://www.geographyrealm.com/terrestrial-ecoregions-gis-data/).\n",
        "2.  Replace `your/url/here` with the URL you found, making sure to format it so it is easily readable. Also, replace `ecoregions_dirname` and `ecoregions_filename` with descriptive and machine-readable names for your project's file structure.\n",
        "3.  Change all the variable names to **descriptive** variable names, making sure to correctly reference variables you created before.\n",
        "4.  Run the cell to download and save the data.\n",
        ":::\n"
      ],
      "id": "d74dfa58"
    },
    {
      "cell_type": "code",
      "metadata": {
        "class": "student-code",
        "highlight": true
      },
      "source": [
        "#| echo: true\n",
        "#| eval: false\n",
        "# Set up the ecoregion boundary URL\n",
        "url = \"your/url/here\"\n",
        "\n",
        "# Set up a path to save the data on your machine\n",
        "the_dir = os.path.join(project_data_dir, 'ecoregions_dirname')\n",
        "# Make the ecoregions directory\n",
        "\n",
        "# Join ecoregions shapefile path\n",
        "a_path = os.path.join(the_dir, 'ecoregions_filename.shp')\n",
        "\n",
        "# Only download once\n",
        "if not os.path.exists(a_path):\n",
        "    my_gdf = gpd.read_file(your_url_here)\n",
        "    my_gdf.to_file(your_path_here)"
      ],
      "id": "d7ea4c7b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.content-visible when-format=\"html\"}\n"
      ],
      "id": "ef959191"
    },
    {
      "cell_type": "code",
      "metadata": {
        "class": "answer-code",
        "highlight": true
      },
      "source": [
        "#| echo: true\n",
        "#| eval: true\n",
        "#| code-fold: true\n",
        "#| code-summary: See our solution!\n",
        "# Set up the ecoregion boundary URL\n",
        "ecoregions_url = (\n",
        "    \"https://storage.googleapis.com/teow2016/Ecoregions2017.zip\")\n",
        "\n",
        "# Set up a path to save the data on your machine\n",
        "ecoregions_dir = os.path.join(data_dir, 'wwf_ecoregions')\n",
        "os.makedirs(ecoregions_dir, exist_ok=True)\n",
        "ecoregions_path = os.path.join(ecoregions_dir, 'wwf_ecoregions.shp')\n",
        "\n",
        "# Only download once\n",
        "if not os.path.exists(ecoregions_path):\n",
        "    ecoregions_gdf = gpd.read_file(ecoregions_url)\n",
        "    ecoregions_gdf.to_file(ecoregions_path)"
      ],
      "id": "55516b5d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "Let's check that that worked! To do so we'll use a **bash** command called `find` to look for all the files in your project directory with the `.shp` extension:\n"
      ],
      "id": "cf57991d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "%%bash\n",
        "find ~/earth-analytics/data/migration -name '*.shp' "
      ],
      "id": "e7d79d29",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.callout-tip}\n",
        "You can also run bash commands in the terminal!\n",
        ":::\n",
        "\n",
        "::: {.callout-read}\n",
        "Learn more about bash in this [Introduction to Bash](https://www.earthdatascience.org/courses/intro-to-earth-data-science/open-reproducible-science/bash/)\n",
        ":::\n",
        "\n",
        "### Load the ecoregions into Python\n",
        "\n",
        "::: {.callout-task title=\"Load ecoregions into Python\"}\n",
        "\n",
        "Download and save ecoregion boundaries from the EPA:\n",
        "\n",
        "1.  Replace `a_path` with the path your created for your ecoregions file.\n",
        "2.  (optional) Consider renaming and selecting columns to make your `GeoDataFrame` easier to work with. Many of the same methods you learned for `pandas` `DataFrame`s are the same for `GeoDataFrame`s! NOTE: Make sure to keep the `'SHAPE_AREA'` column around -- we will need that later!\n",
        "3.  Make a quick plot with `.plot()` to make sure the download worked.\n",
        "4.  Run the cell to load the data into Python\n",
        ":::\n"
      ],
      "id": "b442b474"
    },
    {
      "cell_type": "code",
      "metadata": {
        "class": "student-code",
        "highlight": true
      },
      "source": [
        "#| echo: true\n",
        "#| eval: false\n",
        "# Open up the ecoregions boundaries\n",
        "gdf = gpd.read_file(a_path)\n",
        "\n",
        "# Name the index so it will match the other data later on\n",
        "gdf.index.name = 'ecoregion'\n",
        "\n",
        "# Plot the ecoregions to check download"
      ],
      "id": "32a49ac4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.content-visible when-format=\"html\"}\n"
      ],
      "id": "ed95551d"
    },
    {
      "cell_type": "code",
      "metadata": {
        "class": "answer-code",
        "highlight": true
      },
      "source": [
        "#| echo: true\n",
        "#| eval: true\n",
        "#| code-fold: true\n",
        "#| code-summary: See our solution!\n",
        "# Open up the ecoregions boundaries\n",
        "ecoregions_gdf = (\n",
        "    gpd.read_file(ecoregions_path)\n",
        "    .rename(columns={\n",
        "        'ECO_NAME': 'name',\n",
        "        'SHAPE_AREA': 'area'})\n",
        "    [['name', 'area', 'geometry']]\n",
        ")\n",
        "\n",
        "# We'll name the index so it will match the other data\n",
        "ecoregions_gdf.index.name = 'ecoregion'\n",
        "\n",
        "# Plot the ecoregions to check download\n",
        "ecoregions_gdf.plot(edgecolor='black', color='skyblue')"
      ],
      "id": "1330145a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "## STEP 3: Download species observation data\n",
        "\n",
        "For this challenge, you will use a database called the [Global Biodiversity Information Facility (GBIF)](https://www.gbif.org/). GBIF is compiled from species observation data all over the world, and includes everything from museum specimens to photos taken by citizen scientists in their backyards. We've compiled some sample data in the same format that you will get from GBIF.\n",
        "\n",
        "### Download sample data\n",
        "\n",
        "::: {.callout-task title=\"Import GBIF Data\"}\n",
        "\n",
        "1. Define the `gbif_url` to be this sample data URL `{{ params.sample_url }}`\n",
        "2. Using the ecoregions code, modify the code cell below so that the download only runs once, as with the ecoregion data.\n",
        "3. Run the cell\n",
        ":::\n"
      ],
      "id": "bf05365b"
    },
    {
      "cell_type": "code",
      "metadata": {
        "class": "student-code",
        "highlight": true
      },
      "source": [
        "#| echo: true\n",
        "#| eval: false\n",
        "# Load the GBIF data\n",
        "gbif_df = pd.read_csv(\n",
        "    gbif_url, \n",
        "    delimiter='\\t',\n",
        "    index_col='gbifID',\n",
        "    usecols=['gbifID', 'decimalLatitude', 'decimalLongitude', 'month'])\n",
        "gbif_df.head()"
      ],
      "id": "d0ed6768",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.content-visible when-format=\"html\"}\n"
      ],
      "id": "e012d5b0"
    },
    {
      "cell_type": "code",
      "metadata": {
        "class": "answer-code",
        "highlight": true
      },
      "source": [
        "#| echo: true\n",
        "#| eval: true\n",
        "#| code-fold: true\n",
        "#| code-summary: See our solution!\n",
        "# Define the sample data URL\n",
        "gbif_url = (\n",
        "    \"https://github.com/cu-esiil-edu/esiil-learning-portal/releases/download\"\n",
        "    \"/data-release/__param_sample_filename.zip\")\n",
        "    \n",
        "# Set up a path to save the data on your machine\n",
        "gbif_filename = \"__param_download_filename\"\n",
        "gbif_dir = os.path.join(data_dir, gbif_filename)\n",
        "os.makedirs(gbif_dir, exist_ok=True)\n",
        "gbif_path = os.path.join(gbif_dir, f\"{ gbif_filename }.zip\")\n",
        "\n",
        "# Only download once\n",
        "if not os.path.exists(gbif_path):\n",
        "    # Load the GBIF data\n",
        "    gbif_df = pd.read_csv(\n",
        "        gbif_url, \n",
        "        delimiter='\\t',\n",
        "        index_col='gbifID',\n",
        "        usecols=['gbifID', 'decimalLatitude', 'decimalLongitude', 'month'])\n",
        "    # Save the GBIF data\n",
        "    gbif_df.to_csv(gbif_path, index=False)\n",
        "\n",
        "gbif_df = pd.read_csv(gbif_path)\n",
        "gbif_df.head()"
      ],
      "id": "bb837b59",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "### Convert the GBIF data to a GeoDataFrame\n",
        "\n",
        "To plot the GBIF data, we need to convert it to a `GeoDataFrame` first. This will make some special geospatial operations from `geopandas` available, such as spatial joins and plotting.\n",
        "\n",
        "::: {.callout-task title=\"Convert `DataFrame` to `GeoDataFrame`\"}\n",
        "\n",
        "1.  Replace `your_dataframe` with the name of the `DataFrame` you just got from GBIF\n",
        "2.  Replace `longitude_column_name` and `latitude_column_name` with column names from your \\`DataFrame\n",
        "3.  Run the code to get a `GeoDataFrame` of the GBIF data.\n",
        ":::\n"
      ],
      "id": "f0813581"
    },
    {
      "cell_type": "code",
      "metadata": {
        "class": "student-code",
        "highlight": true
      },
      "source": [
        "#| echo: true\n",
        "#| eval: false\n",
        "gbif_gdf = (\n",
        "    gpd.GeoDataFrame(\n",
        "        your_dataframe, \n",
        "        geometry=gpd.points_from_xy(\n",
        "            your_dataframe.longitude_column_name, \n",
        "            your_dataframe.latitude_column_name), \n",
        "        crs=\"EPSG:4326\")\n",
        "    # Select the desired columns\n",
        "    [[]]\n",
        ")\n",
        "gbif_gdf"
      ],
      "id": "626ecee5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.content-visible when-format=\"html\"}\n"
      ],
      "id": "2eee666b"
    },
    {
      "cell_type": "code",
      "metadata": {
        "class": "answer-code",
        "highlight": true
      },
      "source": [
        "#| echo: true\n",
        "#| eval: true\n",
        "#| code-fold: true\n",
        "#| code-summary: See our solution!\n",
        "gbif_gdf = (\n",
        "    gpd.GeoDataFrame(\n",
        "        gbif_df, \n",
        "        geometry=gpd.points_from_xy(\n",
        "            gbif_df.decimalLongitude, \n",
        "            gbif_df.decimalLatitude), \n",
        "        crs=\"EPSG:4326\")\n",
        "    # Select the desired columns\n",
        "    [['month', 'geometry']]\n",
        ")\n",
        "gbif_gdf"
      ],
      "id": "5055e091",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "::: {.content-visible when-format=\"ipynb\"}\n",
        "::: {.callout-task}\n",
        "Make sure to store the new version of your `DataFrame` for other notebooks!\n"
      ],
      "id": "e28b14bd"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "%store ecoregions_gdf gbif_gdf"
      ],
      "id": "25c8b325",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        ":::\n",
        "\n",
        "\n",
        "## STEP 4: Count the number of observations in each ecosystem, during each month of 2023\n",
        "\n",
        "Much of the data in GBIF is **crowd-sourced**. As a result, we need not just the number of observations in each ecosystem each month -- we need to **normalize** by some measure of **sampling effort**. After all, we wouldn't expect the same number of observations at the North Pole as we would in a National Park, even if there were the same number organisms. In this case, we're normalizing using the average number of observations for each ecosystem and each month. This should help control for the number of active observers in each location and time of year.\n",
        "\n",
        "::: {.content-visible when-format=\"ipynb\"}\n",
        "\n",
        "### Set up your analysis\n",
        "\n",
        "First things first -- let's load your stored variables.\n"
      ],
      "id": "746ecf03"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: true\n",
        "%store -r ecoregions_gdf gbif_gdf"
      ],
      "id": "5768ff49",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "### Identify the ecoregion for each observation\n",
        "\n",
        "You can combine the ecoregions and the observations **spatially** using a method called `.sjoin()`, which stands for spatial join.\n",
        "\n",
        "::: {.callout-read}\n",
        "\n",
        "Check out the [`geopandas` documentation on spatial joins](https://geopandas.org/en/stable/docs/user_guide/mergingdata.html#spatial-joins) to help you figure this one out. You can also ask your favorite LLM (Large-Language Model, like ChatGPT)\n",
        ":::\n",
        "\n",
        "::: {.callout-task title=\"Perform a spatial join\"}\n",
        "\n",
        "1.  Identify the correct values for the `how=` and `predicate=` parameters of the spatial join.\n",
        "2.  Select only the columns you will need for your plot.\n",
        "3.  Run the code.\n",
        "\n",
        ":::\n"
      ],
      "id": "cd942df3"
    },
    {
      "cell_type": "code",
      "metadata": {
        "class": "student-code",
        "highlight": true
      },
      "source": [
        "#| echo: true\n",
        "#| eval: false\n",
        "gbif_ecoregion_gdf = (\n",
        "    ecoregions_gdf\n",
        "    # Match the CRS of the GBIF data and the ecoregions\n",
        "    .to_crs(gbif_gdf.crs)\n",
        "    # Find ecoregion for each observation\n",
        "    .sjoin(\n",
        "        gbif_gdf,\n",
        "        how='', \n",
        "        predicate='')\n",
        "    # Select the required columns\n",
        "    \n",
        ")\n",
        "gbif_ecoregion_gdf"
      ],
      "id": "88df6a76",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.content-visible when-format=\"html\"}\n"
      ],
      "id": "1142615b"
    },
    {
      "cell_type": "code",
      "metadata": {
        "class": "answer-code",
        "highlight": true
      },
      "source": [
        "#| echo: true\n",
        "#| eval: true\n",
        "#| code-fold: true\n",
        "#| code-summary: See our solution!\n",
        "gbif_ecoregion_gdf = (\n",
        "    ecoregions_gdf\n",
        "    # Match the CRS of the GBIF data and the ecoregions\n",
        "    .to_crs(gbif_gdf.crs)\n",
        "    # Find ecoregion for each observation\n",
        "    .sjoin(\n",
        "        gbif_gdf,\n",
        "        how='inner', \n",
        "        predicate='contains')\n",
        "    # Select the required columns\n",
        "    [['month', 'name']]\n",
        ")\n",
        "gbif_ecoregion_gdf"
      ],
      "id": "f91b476e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "### Count the observations in each ecoregion each month\n",
        "\n",
        "::: {.callout-task title=\"Group observations by ecoregion\"}\n",
        "\n",
        "1.  Replace `columns_to_group_by` with a list of columns. Keep in mind that you will end up with one row for each group -- you want to count the observations in each ecoregion by month.\n",
        "2.  Select only month/ecosystem combinations that have more than one occurrence recorded, since a single occurrence could be an error.\n",
        "3.  Use the `.groupby()` and `.mean()` methods to compute the mean occurrences by ecoregion and by month.\n",
        "4.  Run the code -- it will normalize the number of occurrences by month and ecoretion.\n",
        ":::\n"
      ],
      "id": "5b6c5460"
    },
    {
      "cell_type": "code",
      "metadata": {
        "class": "student-code",
        "highlight": true
      },
      "source": [
        "#| echo: true\n",
        "#| eval: false\n",
        "occurrence_df = (\n",
        "    gbif_ecoregion_gdf\n",
        "    # For each ecoregion, for each month...\n",
        "    .groupby(columns_to_group_by)\n",
        "    # ...count the number of occurrences\n",
        "    .agg(occurrences=('name', 'count'))\n",
        ")\n",
        "\n",
        "# Get rid of rare observations (possible misidentification?)\n",
        "occurrence_df = occurrence_df[...]\n",
        "\n",
        "# Take the mean by ecoregion\n",
        "mean_occurrences_by_ecoregion = (\n",
        "    occurrence_df\n",
        "    ...\n",
        ")\n",
        "# Take the mean by month\n",
        "mean_occurrences_by_month = (\n",
        "    occurrence_df\n",
        "    ...\n",
        ")"
      ],
      "id": "38bcbfa0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.content-visible when-format=\"html\"}\n"
      ],
      "id": "c0f7015e"
    },
    {
      "cell_type": "code",
      "metadata": {
        "class": "answer-code",
        "highlight": true
      },
      "source": [
        "#| echo: true\n",
        "#| eval: true\n",
        "#| code-fold: true\n",
        "#| code-summary: See our solution!\n",
        "occurrence_df = (\n",
        "    gbif_ecoregion_gdf\n",
        "    # For each ecoregion, for each month...\n",
        "    .groupby(['ecoregion', 'month'])\n",
        "    # ...count the number of occurrences\n",
        "    .agg(occurrences=('name', 'count'))\n",
        ")\n",
        "\n",
        "# Get rid of rare observation noise (possible misidentification?)\n",
        "occurrence_df = occurrence_df[occurrence_df.occurrences>1]\n",
        "\n",
        "# Take the mean by ecoregion\n",
        "mean_occurrences_by_ecoregion = (\n",
        "    occurrence_df\n",
        "    .groupby(['ecoregion'])\n",
        "    .mean()\n",
        ")\n",
        "# Take the mean by month\n",
        "mean_occurrences_by_month = (\n",
        "    occurrence_df\n",
        "    .groupby(['month'])\n",
        "    .mean()\n",
        ")"
      ],
      "id": "f509e3a9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "### Normalize the observations\n",
        "\n",
        "::: {.callout-task title=\"Normalize\"}\n",
        "\n",
        "1.  Divide occurrences by the mean occurrences by month AND the mean occurrences by ecoregion\n",
        ":::\n"
      ],
      "id": "bc7be268"
    },
    {
      "cell_type": "code",
      "metadata": {
        "class": "student-code",
        "highlight": true
      },
      "source": [
        "#| echo: true\n",
        "#| eval: false\n",
        "# Normalize by space and time for sampling effort\n",
        "occurrence_df['norm_occurrences'] = (\n",
        "    occurrence_df\n",
        "    ...\n",
        ")\n",
        "occurrence_df"
      ],
      "id": "cf212361",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.content-visible when-format=\"html\"}\n"
      ],
      "id": "389e8289"
    },
    {
      "cell_type": "code",
      "metadata": {
        "class": "answer-code",
        "highlight": true
      },
      "source": [
        "#| echo: true\n",
        "#| eval: true\n",
        "#| code-fold: true\n",
        "#| code-summary: See our solution!\n",
        "occurrence_df['norm_occurrences'] = (\n",
        "    occurrence_df\n",
        "    / mean_occurrences_by_ecoregion\n",
        "    / mean_occurrences_by_month\n",
        ")\n",
        "occurrence_df"
      ],
      "id": "dfd78bca",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "::: {.content-visible when-format=\"ipynb\"}\n",
        "::: {.callout-task}\n",
        "Make sure to store the new version of your `DataFrame` for other notebooks!\n"
      ],
      "id": "550f45bf"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "%store occurrence_df"
      ],
      "id": "142a7121",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        ":::\n",
        "\n",
        "\n",
        "## STEP 5: Plot the __param_species_name observations by month\n",
        "\n",
        "First thing first -- let's load your stored variables and import libraries.\n"
      ],
      "id": "b7e22919"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: true\n",
        "%store -r ecoregions_gdf occurrence_df"
      ],
      "id": "04984a17",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.callout-task title=\"Import packages\"}\n",
        "\n",
        "In the imports cell, we've included some packages that you will need. Add imports for packages that will help you:\n",
        "\n",
        "1. Make interactive maps with vector data\n",
        "\n",
        ":::\n"
      ],
      "id": "1f825a3d"
    },
    {
      "cell_type": "code",
      "metadata": {
        "class": "student-code",
        "highlight": true
      },
      "source": [
        "#| echo: true\n",
        "#| eval: false\n",
        "# Get month names\n",
        "import calendar\n",
        "\n",
        "# Libraries for Dynamic mapping\n",
        "import cartopy.crs as ccrs\n",
        "import panel as pn"
      ],
      "id": "f997d04e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.content-visible when-format=\"html\"}\n"
      ],
      "id": "6a6e6aea"
    },
    {
      "cell_type": "code",
      "metadata": {
        "class": "answer-code",
        "highlight": true
      },
      "source": [
        "#| echo: true\n",
        "#| eval: true\n",
        "#| code-fold: true\n",
        "#| code-summary: See our solution!\n",
        "# Get month names\n",
        "import calendar\n",
        "\n",
        "# Libraries for Dynamic mapping\n",
        "import cartopy.crs as ccrs\n",
        "import hvplot.pandas\n",
        "import panel as pn"
      ],
      "id": "ccfa4f68",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "### Create a simplified `GeoDataFrame` for plotting\n",
        "\n",
        "Plotting larger files can be time consuming. The code below will streamline plotting with `hvplot` by simplifying the geometry, projecting it to a Mercator projection that is compatible with `geoviews`, and cropping off areas in the Arctic.\n",
        "\n",
        "::: {.callout-task title=\"Simplify ecoregion data\"}\n",
        "\n",
        "Download and save ecoregion boundaries from the EPA:\n",
        "\n",
        "1. Simplify the ecoregions with `.simplify(.05)`, and save it back to the `geometry` column.\n",
        "2.  Change the Coordinate Reference System (CRS) to Mercator with `.to_crs(ccrs.Mercator())`\n",
        "3.  Use the plotting code that is already in the cell to check that the plotting runs quickly (less than a minute) and looks the way you want, making sure to change `gdf` to YOUR `GeoDataFrame` name.\n",
        "\n",
        ":::\n"
      ],
      "id": "0a8b6dc2"
    },
    {
      "cell_type": "code",
      "metadata": {
        "class": "student-code",
        "highlight": true
      },
      "source": [
        "#| echo: true\n",
        "#| eval: false\n",
        "# Simplify the geometry to speed up processing\n",
        "\n",
        "# Change the CRS to Mercator for mapping\n",
        "\n",
        "# Check that the plot runs in a reasonable amount of time\n",
        "gdf.hvplot(geo=True, crs=ccrs.Mercator())"
      ],
      "id": "257c5b08",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.content-visible when-format=\"html\"}\n"
      ],
      "id": "23aafdb1"
    },
    {
      "cell_type": "code",
      "metadata": {
        "class": "answer-code",
        "highlight": true
      },
      "source": [
        "#| echo: true\n",
        "#| eval: true\n",
        "#| code-fold: true\n",
        "#| code-summary: See our solution!\n",
        "# Simplify the geometry to speed up processing\n",
        "ecoregions_gdf.geometry = ecoregions_gdf.simplify(\n",
        "    .05, preserve_topology=False)\n",
        "\n",
        "# Change the CRS to Mercator for mapping\n",
        "ecoregions_gdf = ecoregions_gdf.to_crs(ccrs.Mercator())\n",
        "\n",
        "# Check that the plot runs\n",
        "ecoregions_gdf.hvplot(geo=True, crs=ccrs.Mercator())"
      ],
      "id": "7320a81c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "::: {.callout-task title=\"Map migration over time\"}\n",
        "\n",
        "1. If applicable, replace any variable names with the names you defined previously.\n",
        "2. Replace `column_name_used_for_ecoregion_color` and `column_name_used_for_slider` with the column names you wish to use.\n",
        "3. Customize your plot with your choice of title, tile source, color map, and size.\n",
        "\n",
        ":::: {.callout-note}\n",
        "Your plot will probably still change months very slowly in your Jupyter notebook, because it calculates each month's plot as needed. Open up the saved HTML file to see faster performance!\n",
        "::::\n",
        ":::\n"
      ],
      "id": "17c41556"
    },
    {
      "cell_type": "code",
      "metadata": {
        "class": "student-code",
        "highlight": true
      },
      "source": [
        "#| echo: true\n",
        "#| eval: false\n",
        "# Join the occurrences with the plotting GeoDataFrame\n",
        "occurrence_gdf = ecoregions_gdf.join(occurrence_df)\n",
        "\n",
        "# Get the plot bounds so they don't change with the slider\n",
        "xmin, ymin, xmax, ymax = occurrence_gdf.total_bounds\n",
        "\n",
        "# Plot occurrence by ecoregion and month\n",
        "migration_plot = (\n",
        "    occurrence_gdf\n",
        "    .hvplot(\n",
        "        c=column_name_used_for_shape_color,\n",
        "        groupby=column_name_used_for_slider,\n",
        "        # Use background tiles\n",
        "        geo=True, crs=ccrs.Mercator(), tiles='CartoLight',\n",
        "        title=\"Your Title Here\",\n",
        "        xlim=(xmin, xmax), ylim=(ymin, ymax),\n",
        "        frame_height=600,\n",
        "        widget_location='bottom'\n",
        "    )\n",
        ")\n",
        "\n",
        "# Save the plot\n",
        "migration_plot.save('migration.html', embed=True)\n",
        "\n",
        "# Show the plot\n",
        "migration_plot"
      ],
      "id": "a5669c72",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.content-visible when-format=\"html\"}\n"
      ],
      "id": "199afd46"
    },
    {
      "cell_type": "code",
      "metadata": {
        "class": "answer-code",
        "highlight": true
      },
      "source": [
        "#| echo: true\n",
        "#| eval: true\n",
        "#| code-fold: true\n",
        "#| code-summary: See our solution!\n",
        "# Join the occurrences with the plotting GeoDataFrame\n",
        "occurrence_gdf = ecoregions_gdf.join(occurrence_df)\n",
        "\n",
        "# Get the plot bounds so they don't change with the slider\n",
        "xmin, ymin, xmax, ymax = occurrence_gdf.total_bounds\n",
        "\n",
        "# Define the slider widget\n",
        "slider = pn.widgets.DiscreteSlider(\n",
        "    name='month',\n",
        "    options={calendar.month_name[i]: i for i in range(1, 13)}\n",
        ")\n",
        "\n",
        "# Plot occurrence by ecoregion and month\n",
        "migration_plot = (\n",
        "    occurrence_gdf\n",
        "    .hvplot(\n",
        "        c='norm_occurrences',\n",
        "        groupby='month',\n",
        "        # Use background tiles\n",
        "        geo=True, crs=ccrs.Mercator(), tiles='CartoLight',\n",
        "        title=\"__param_species_name migration\",\n",
        "        xlim=(xmin, xmax), ylim=(ymin, ymax),\n",
        "        frame_width=500,\n",
        "        colorbar=False,\n",
        "        widgets={'month': slider},\n",
        "        widget_location='bottom'\n",
        "    )\n",
        ")\n",
        "\n",
        "# Save the plot (if possible)\n",
        "try:\n",
        "    migration_plot.save('__param_plot_filename.html', embed=True)\n",
        "except Exception as exc:\n",
        "    print('Could not save the migration plot due to the following error:')\n",
        "    print(exc)"
      ],
      "id": "76ad0211",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "::: {.content-visible when-format=\"html\"}\n",
        "\n",
        "\n",
        "```{=html}\n",
        "<embed type=\"text/html\" src=\"__param_plot_filename.html\" width=\"600\" height=\"800\">\n",
        "```\n",
        "\n",
        "\n",
        ":::\n",
        "\n",
        "::: {.callout-extra title=\"Fix the month labels\"}\n",
        "\n",
        "Notice that the `month` slider displays numbers instead of the month name. Use `pn.widgets.DiscreteSlider()` with the `options=` parameter set to give the months names. You might want to try asking ChatGPT how to do this, or look at the documentation for `pn.widgets.DiscreteSlider()`. This is pretty tricky!\n",
        ":::\n"
      ],
      "id": "ff8914ca"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Users/elsa/miniconda3/envs/learning-portal/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}