[
  {
    "objectID": "notebooks/05-vegetation/vegetation.html",
    "href": "notebooks/05-vegetation/vegetation.html",
    "title": "The Cameron Peak Fire, Colorado, USA",
    "section": "",
    "text": "The Cameron Peak Fire was the largest fire in Colorado history, with 326 square miles burned."
  },
  {
    "objectID": "notebooks/05-vegetation/vegetation.html#observing-vegetation-health-from-space",
    "href": "notebooks/05-vegetation/vegetation.html#observing-vegetation-health-from-space",
    "title": "The Cameron Peak Fire, Colorado, USA",
    "section": "Observing vegetation health from space",
    "text": "Observing vegetation health from space\nWe will look at the destruction and recovery of vegetation using NDVI (Normalized Difference Vegetation Index). How does it work? First, we need to learn about spectral reflectance signatures.\nEvery object reflects some wavelengths of light more or less than others. We can see this with our eyes, since, for example, plants reflect a lot of green in the summer, and then as that green diminishes in the fall they look more yellow or orange. The image below shows spectral signatures for water, soil, and vegetation:\n &gt; Image source: SEOS Project\nHealthy vegetation reflects a lot of Near-InfraRed (NIR) radiation. Less healthy vegetation reflects a similar amounts of the visible light spectra, but less NIR radiation. We don’t see a huge drop in Green radiation until the plant is very stressed or dead. That means that NIR allows us to get ahead of what we can see with our eyes.\n &gt; Image source: Spectral signature literature review by px39n\nDifferent species of plants reflect different spectral signatures, but the pattern of the signatures are similar. NDVI compares the amount of NIR reflectance to the amount of Red reflectance, thus accounting for many of the species differences and isolating the health of the plant. The formula for calculating NDVI is:\n\\[NDVI = \\frac{(NIR - Red)}{(NIR + Red)}\\]\nRead more about NDVI and other vegetation indices: * earthdatascience.org * USGS\n\n\n\n\n\n\n Import necessary libraries\n\n\n\nIn the cell below, making sure to keep the packages in order, add packages for:\n\nWorking with DataFrames\nWorking with GeoDataFrames\nMaking interactive plots of tabular and vector data\n\n What are we using the rest of these packages for? See if you can figure it out as you complete the notebook.\n\n\n\nimport getpass\nimport json\nimport os\nimport pathlib\nfrom glob import glob\n\nimport earthpy.appeears as eaapp\nimport hvplot.xarray\nimport rioxarray as rxr\nimport xarray as xr\n\n\n\nSee our solution!\nimport getpass\nimport json\nimport os\nimport pathlib\nfrom glob import glob\n\nimport earthpy.appeears as eaapp\nimport geopandas as gpd\nimport hvplot.pandas\nimport hvplot.xarray\nimport pandas as pd\nimport rioxarray as rxr\nimport xarray as xr\n\n\nWe have one more setup task. We’re not going to be able to load all our data directly from the web to Python this time. That means we need to set up a place for it.\n\n\n\n\n\n\n GOTCHA ALERT\n\n\n\nA lot of times in Python we say “directory” to mean a “folder” on your computer. The two words mean the same thing in this context.\n\n\n\n\n\n\n\n\n Your task\n\n\n\nIn the cell below, replace ‘my-data-folder’ with a descriptive directory name.\n\n\n\ndata_dir = os.path.join(pathlib.Path.home(), 'my-data-folder')\n# Make the data directory\nos.makedirs(data_dir, exist_ok=True)\n\n\n\nSee our solution!\ndata_dir = os.path.join(\n    pathlib.Path.home(), 'earth-analytics', 'data', 'cameron-peak')\n# Make the data directory\nos.makedirs(data_dir, exist_ok=True)"
  },
  {
    "objectID": "notebooks/05-vegetation/vegetation.html#study-area-cameron-peak-fire-boundary",
    "href": "notebooks/05-vegetation/vegetation.html#study-area-cameron-peak-fire-boundary",
    "title": "The Cameron Peak Fire, Colorado, USA",
    "section": "Study Area: Cameron Peak Fire Boundary",
    "text": "Study Area: Cameron Peak Fire Boundary\n\nEarth Data Science data formats\nIn Earth Data Science, we get data in three main formats:\n\n\n\n\n\n\n\n\n\nData type\nDescriptions\nCommon file formats\nPython type\n\n\n\n\nTime Series\nThe same data points (e.g. streamflow) collected multiple times over time\nTabular formats (e.g. .csv, or .xlsx)\npandas DataFrame\n\n\nVector\nPoints, lines, and areas (with coordinates)\nShapefile (often an archive like a .zip file because a Shapefile is actually a collection of at least 3 files)\ngeopandas GeoDataFrame\n\n\nRaster\nEvenly spaced spatial grid (with coordinates)\nGeoTIFF (.tif), NetCDF (.nc), HDF (.hdf)\nrioxarray DataArray\n\n\n\n\n\n\n\n\n\n Read more\n\n\n\nCheck out the sections about about vector data and raster data in the textbook.\n\n\n\n\n\n\n\n\n What do you think?\n\n\n\nFor this coding challenge, we are interested in the boundary of the Cameron Peak Fire. In the cell below, answer the following question: What data type do you think the fire boundary will be?\n\n\n\n\n\n\n\n\n Your task:\n\n\n\n\nSearch the National Interagency Fire Center Wildfire Boundary catalog for and incident name “Cameron Peak”\nCopy the API results to your clipboard.\nLoad the data into Python using the geopandas library, e.g.: python      gpd.read_file(url)\nCall your data at the end of the cell for testing.\n\n\n\n\n# Download the Cameron Peak fire boundary\n\n\n\nSee our solution!\nurl = (\n    \"https://services3.arcgis.com/T4QMspbfLg3qTGWY/arcgis/rest/services\"\n    \"/WFIGS_Interagency_Perimeters/FeatureServer/0/query\"\n    \"?where=poly_IncidentName%20%3D%20'CAMERON%20PEAK'\"\n    \"&outFields=*&outSR=4326&f=json\")\n\ngdf = gpd.read_file(url)\ngdf\n\n\n\nans_gdf = _\ngdf_pts = 0\n\nif isinstance(ans_gdf, gpd.GeoDataFrame):\n    print('\\u2705 Great work! You downloaded and opened a GeoDataFrame')\n    gdf_pts +=2\nelse:\n    print('\\u274C Hmm, your answer is not a GeoDataFrame')\n\nprint('\\u27A1 You earned {} of 2 points for downloading data'.format(gdf_pts))\n\n\n\nSite Map\nWe always want to create a site map when working with geospatial data. This helps us see that we’re looking at the right location, and learn something about the context of the analysis.\n\n\n\n\n\n\n Your task\n\n\n\n\nPlot your Cameron Peak Fire shapefile on an interactive map\nMake sure to add a title\nAdd ESRI World Imagery as the basemap/background using the tiles=... parameter. To get the tiles to match up with your data, you will also need to add the geo=True parameter.\n\n\n\n\n# Plot the Cameron Peak Fire boundary\n\n\ngdf.hvplot(\n    geo=True,\n    title='Cameron Peak Fire, 2020',\n    tiles='EsriImagery')"
  },
  {
    "objectID": "notebooks/05-vegetation/vegetation.html#exploring-the-appeears-api-for-nasa-earthdata-access",
    "href": "notebooks/05-vegetation/vegetation.html#exploring-the-appeears-api-for-nasa-earthdata-access",
    "title": "The Cameron Peak Fire, Colorado, USA",
    "section": "Exploring the AppEEARS API for NASA Earthdata access",
    "text": "Exploring the AppEEARS API for NASA Earthdata access\nBefore you get started with the data download today, you will need a free NASA Earthdata account if you don’t have one already!\nOver the next four cells, you will download MODIS NDVI data for the study period. MODIS is a multispectral instrument that measures Red and NIR data (and so can be used for NDVI). There are two MODIS sensors on two different platforms: satellites Terra and Aqua.\n\n\n\n\n\n\n Read more\n\n\n\nLearn more about MODIS datasets and the science they support\n\n\nSince we’re asking for a special download that only covers our study area, we can’t just find a link to the data - we have to negotiate with the data server. We’re doing this using the APPEEARS API (Application Programming Interface). The API makes it possible for you to request data using code. You can use code from the earthpy library to handle the API request.\n\n\n\n\n\n\n Your task\n\n\n\nOften when we want to do something more complex in coding we find an example and modify it. This download code is already almost a working example. Your task will be:\n\nReplace the start and end dates in the task parameters. Download data from July, when greenery is at its peak in the Northern Hemisphere.\nReplace the year range. You should get 3 years before and after the fire so you can see the change!\nReplace gdf with the name of your site geodataframe.\nEnter your NASA Earthdata username and password when prompted. The prompts can be a little hard to see – look at the top of your screen!\n\n What would the product and layer name be if you were trying to download Landsat Surface Temperature Analysis Ready Data (ARD) instead of MODIS NDVI?\n\n\n\n\n\n\n\n\nImportant\n\n\n\nIt can take some time for Appeears to process your request - anything from a few minutes to a few hours depending on how busy they are. You can check your progress by:\n\nGoing to the Appeears webpage\nClicking the Explore tab\nLogging in with your Earthdata account\n\n\n\n\n# Initialize AppeearsDownloader for MODIS NDVI data\nndvi_downloader = eaapp.AppeearsDownloader(\n    download_key='cp-ndvi',\n    ea_dir=data_dir,\n    product='MOD13Q1.061',\n    layer='_250m_16_days_NDVI',\n    start_date=\"01-01\",\n    end_date=\"01-31\",\n    recurring=True,\n    year_range=[2021, 2021],\n    polygon=gdf\n)\n# Download the prepared download -- this can take some time!\nndvi_downloader.download_files(cache=True)\n\n\n# Initialize AppeearsDownloader for MODIS NDVI data\nndvi_downloader = eaapp.AppeearsDownloader(\n    download_key='cp-ndvi',\n    ea_dir=data_dir,\n    product='MOD13Q1.061',\n    layer='_250m_16_days_NDVI',\n    start_date=\"07-01\",\n    end_date=\"07-31\",\n    recurring=True,\n    year_range=[2018, 2023],\n    polygon=gdf\n)\nndvi_downloader.download_files(cache=True)"
  },
  {
    "objectID": "notebooks/05-vegetation/vegetation.html#putting-it-together-working-with-multi-file-raster-datasets-in-python",
    "href": "notebooks/05-vegetation/vegetation.html#putting-it-together-working-with-multi-file-raster-datasets-in-python",
    "title": "The Cameron Peak Fire, Colorado, USA",
    "section": "Putting it together: Working with multi-file raster datasets in Python",
    "text": "Putting it together: Working with multi-file raster datasets in Python\nNow you need to load all the downloaded files into Python. Let’s start by getting all the file names. You will also need to extract the date from the filename. Check out the lesson on getting information from filenames in the textbook.\n\n\n\n\n\n\n GOTCHA ALERT\n\n\n\nglob doesn’t necessarily find files in the order you would expect. Make sure to sort your file names like it says in the textbook.\n\n\n\n# Get a list of NDVI tif file paths\n\n\n\nSee our solution!\n# Get list of NDVI tif file paths\nndvi_paths = sorted(glob(os.path.join(data_dir, 'cp-ndvi', '*', '*NDVI*.tif')))\nlen(ndvi_paths)\n\n\n\nRepeating tasks in Python\nNow you should have a few dozen files! For each file, you need to:\n\nLoad the file in using the rioxarray library\nGet the date from the file name\nAdd the date as a dimension coordinate\nGive your data variable a name\nDivide by the scale factor of 10000\n\nYou don’t want to write out the code for each file! That’s a recipe for copy pasta. Luckily, Python has tools for doing similar tasks repeatedly. In this case, you’ll use one called a for loop.\nThere’s some code below that uses a for loop in what is called an accumulation pattern to process each file. That means that you will save the results of your processing to a list each time you process the files, and then merge all the arrays in the list.\n\n\n\n\n\n\n Your task\n\n\n\n\nLook at the file names. How many characters from the end is the date? doy_start and doy_end are used to extract the day of the year (doy) from the file name. You will need to count characters from the end and change the values to get the right part of the file name. HINT: the index -1 in Python means the last value, -2 second-to-last, and so on.\nReplace any required variable names with your chosen variable names\nChange the scale_factor variable to be the correct scale factor for this NDVI dataset (HINT: NDVI should range between 0 and 1 – check your results!)\n\n\n\n\nscale_factor = 1\ndoy_start = -1\ndoy_end = -1\n\n\n\nSee our solution!\nscale_factor = 10000\ndoy_start = -19\ndoy_end = -12\n\n\n\nndvi_das = []\nfor ndvi_path in ndvi_paths:\n    # Get date from file name\n    doy = ndvi_path[doy_start:doy_end]\n    date = pd.to_datetime(doy, format='%Y%j')\n\n    # Open dataset\n    da = rxr.open_rasterio(ndvi_path, masked=True).squeeze()\n\n    # Add date dimension and clean up metadata\n    da = da.assign_coords({'date': date})\n    da = da.expand_dims({'date': 1})\n    da.name = 'NDVI'\n\n    # Multiple by scale factor\n    da = da / scale_factor\n\n    # Prepare for concatenation\n    ndvi_das.append(da)\n\nlen(ndvi_das)\n\nNext, stack your arrays by date into a time series using the xr.combine_by_coords() function. You will have to tell it which dimension you want to stack your data in.\n\n\nSee our solution!\nndvi_da = xr.combine_by_coords(ndvi_das, coords=['date'])\nndvi_da\n\n\n\n\n\n\n\n\n Plot the change in NDVI spatially\n\n\n\nComplete the following: * Select data from 2021 to 2023 (3 years after the fire) * Take the temporal mean (over the date, not spatially) * Get the NDVI variable (should be a DataArray, not a Dataset) * Repeat for the data from 2018 to 2020 (3 years before the fire) * Subtract the 2018-2020 time period from the 2021-2023 time period * Plot the result using a diverging color map like cmap=plt.cm.PiYG\n\nThere are different types of color maps for different types of data. In this case, we want decreases to be a different color from increases, so we should use a diverging color map. Check out available colormaps in the matplotlib documentation.\n\n For an extra challenge, add the fire boundary to the plot\n\n\n\n# Compute the difference in NDVI before and after the fire\n\n# Plot the difference\n(\n    ndvi_diff.hvplot(x='', y='', cmap='', geo=True)\n    *\n    gdf.hvplot(geo=True, fill_color=None, line_color='black')\n)\n\n\n\nSee our solution!\nndvi_diff = (\n    ndvi_da\n        .sel(date=slice('2021', '2023'))\n        .mean('date')\n        .NDVI \n   - ndvi_da\n        .sel(date=slice('2018', '2020'))\n        .mean('date')\n        .NDVI\n)\n(\n    ndvi_diff.hvplot(x='x', y='y', cmap='PiYG', geo=True)\n    *\n    gdf.hvplot(geo=True, fill_color=None, line_color='black')\n)"
  },
  {
    "objectID": "notebooks/05-vegetation/vegetation.html#your-turn-repeat-this-workflow-in-a-different-time-and-place.",
    "href": "notebooks/05-vegetation/vegetation.html#your-turn-repeat-this-workflow-in-a-different-time-and-place.",
    "title": "The Cameron Peak Fire, Colorado, USA",
    "section": "Your turn! Repeat this workflow in a different time and place.",
    "text": "Your turn! Repeat this workflow in a different time and place.\nIt’s not just fires that affect NDVI! You could look at:\n\nRecovery after a national disaster, like a wildfire or hurricane\nDrought\nDeforestation\nIrrigation\nBeaver reintroduction"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to the ESIIL Learning Portal!",
    "section": "",
    "text": "Welcome to the ESIIL Learning Portal!\nExplore textbooks:\n\nIntroduction to Earth Data Science\nESIIL Data Short Course\nESIIL STARS Textbook"
  },
  {
    "objectID": "pages/03-git-github/03-github-portfolio/05-map.html",
    "href": "pages/03-git-github/03-github-portfolio/05-map.html",
    "title": "Add a map to your website",
    "section": "",
    "text": "Check out our video demo for adding a map to your portfolio:\n\n \n\nDEMO: Add a map to your portfolio by ESIIL\n\n\n\n\n\nVector data are composed of discrete geometric locations (x and y values, or latitude and longitude) that define the “shape” of the spatial object. The organization of the vertices determines the type of vector that you are working with. There are three fundamental types of vector data:\nPoints: Each individual point is defined by a single x, y coordinate. Examples of point data include: sampling locations, the location of individual trees or the location of plots.\nLines: Lines are composed of many (at least 2) vertices, or points, that are connected. For instance, a road or a stream may be represented by a line. This line is composed of a series of segments, each bend in the road or stream represents a vertex that has defined x, y location.\nPolygons: A polygon consists of 3 or more vertices that are connected and closed. Thus, the outlines of plot boundaries, lakes, oceans, and states or countries are often represented by polygons.\n\n\n\nThere are three types of vector data – point, line, and polygon\n\n\n\n\n\n\n\n\nTip\n\n\n\nRead more about working with spatial data using Python in our Intro to Earth Data Science, here.\n\n\n\n\n\nYou’ll need to start by importing some libraries to have access to all the code you need.\nTo run code in Codespaces, click on the play button in the upper left corner of the code you want to run. You may be asked to “Select a kernel”. If you press Return or click on base up at the top, that should select the default kernel.\n\n# Work with vector data\nimport geopandas as gpd\n\n# Save maps and plots to files\nimport holoviews as hv\n# Create interactive maps and plots\nimport hvplot.pandas\n\n# Search for locations by name - this might take a moment\nfrom osmnx import features as osm\n\n\n\n\nYou can use the osmnx package to download and search for spatial vector data in your area, or anywhere around the world.\nIn this case, we’re looking for the location of the United Tribes Technical College campus in North Dakota. The address in here, 'United Tribes Technical College, Bismarck, ND, United States', does not have to be complete or exact, but it should be specific enough to narrow it down.\n\n\n\n\n\n\nTip\n\n\n\nYou can use the Open Street Maps website to fine-tune your address before you copy it into your code.\n\n\nWe are also specifying that we want it to be tagged as a 'college' type of‘amenity’` type. You might have to try a couple different searches with different addresses and/or tags to get the address you want, just like if you are using a map website or app.\n\n\n\n\n\n\nTip\n\n\n\nCheck out the list of all the different amenity types available on Open Street Maps! Different amenity types might be different types of vector data, such as a point location or a building footprint polygon.\n\n\n\n# Search for United Tribes Technical College\nuttc_gdf = osm.features_from_address(\n    'United Tribes Technical College, Bismarck, ND, United States',\n    {'amenity': ['college']})\nuttc_gdf\n\n\nuttc_gdf.plot()\n\nWe have a map of the UTTC Campus!\n\n\n\n\n\n\nWarning\n\n\n\nThe Open Street Maps (OSM) database is not always complete. For example, try searching for UTTC with the {'building': True}, and compare it to the map of the UTTC campus on their website. What do you notice?\n\n\n\n\n\nThere are lots of different ways to create maps and plots in Python. Here, we’re going to use a tool called 'hvplot' and 'geoviews' to create an interactive map, including the online 'EsriImagery' tile source basemap.\n\n# Plot UTTC boundary\nuttc_map = uttc_gdf.hvplot(\n    # Givethe map a descriptive title\n    title=\"United Tribes Technical College, Bismarck, ND\",\n    # Add a basemap\n    geo=True, tiles='EsriImagery',\n    # Change the colors\n    fill_color='white', fill_alpha=0.2,\n    line_color='skyblue', line_width=5,\n    # Change the image size\n    frame_width=400, frame_height=400)\n\n# Save the map as a file to put on the web\nhv.save(uttc_map, 'uttc.html')\n\n# Display the map\nuttc_map\n\n\n\n\nIf you are doing this activity on GitHub Codespaces, you will need to download the map you created:\n\nOpen the Folders tab on the left hand side\nRight-click on uttc.html (or whatever you named your file)\nSelect Download...\n\nThis should download your map.\n::: {.content-hidden when-profile=“nb”}\n\n\n\nYou are now ready to upload your map to your portfolio repository and place it in your webpage. Because it is HTML and not an image, you will need to use the following HTML to get it on your page:\n&lt;embed type=\"text/html\" src=\"uttc.html\" width=\"600\" height=\"600\"&gt;\n\n\n\n\n\n\n\nImportant\n\n\n\nMake sure to make the width and height of your embed element larger than the frame_width and frame_height of your plot, or it will get cut off!\n\n\n:::"
  },
  {
    "objectID": "pages/03-git-github/03-github-portfolio/05-map.html#get-started-with-map-making-using-open-sources-tools",
    "href": "pages/03-git-github/03-github-portfolio/05-map.html#get-started-with-map-making-using-open-sources-tools",
    "title": "Add a map to your website",
    "section": "",
    "text": "Check out our video demo for adding a map to your portfolio:\n\n \n\nDEMO: Add a map to your portfolio by ESIIL\n\n\n\n\n\nVector data are composed of discrete geometric locations (x and y values, or latitude and longitude) that define the “shape” of the spatial object. The organization of the vertices determines the type of vector that you are working with. There are three fundamental types of vector data:\nPoints: Each individual point is defined by a single x, y coordinate. Examples of point data include: sampling locations, the location of individual trees or the location of plots.\nLines: Lines are composed of many (at least 2) vertices, or points, that are connected. For instance, a road or a stream may be represented by a line. This line is composed of a series of segments, each bend in the road or stream represents a vertex that has defined x, y location.\nPolygons: A polygon consists of 3 or more vertices that are connected and closed. Thus, the outlines of plot boundaries, lakes, oceans, and states or countries are often represented by polygons.\n\n\n\nThere are three types of vector data – point, line, and polygon\n\n\n\n\n\n\n\n\nTip\n\n\n\nRead more about working with spatial data using Python in our Intro to Earth Data Science, here.\n\n\n\n\n\nYou’ll need to start by importing some libraries to have access to all the code you need.\nTo run code in Codespaces, click on the play button in the upper left corner of the code you want to run. You may be asked to “Select a kernel”. If you press Return or click on base up at the top, that should select the default kernel.\n\n# Work with vector data\nimport geopandas as gpd\n\n# Save maps and plots to files\nimport holoviews as hv\n# Create interactive maps and plots\nimport hvplot.pandas\n\n# Search for locations by name - this might take a moment\nfrom osmnx import features as osm\n\n\n\n\nYou can use the osmnx package to download and search for spatial vector data in your area, or anywhere around the world.\nIn this case, we’re looking for the location of the United Tribes Technical College campus in North Dakota. The address in here, 'United Tribes Technical College, Bismarck, ND, United States', does not have to be complete or exact, but it should be specific enough to narrow it down.\n\n\n\n\n\n\nTip\n\n\n\nYou can use the Open Street Maps website to fine-tune your address before you copy it into your code.\n\n\nWe are also specifying that we want it to be tagged as a 'college' type of‘amenity’` type. You might have to try a couple different searches with different addresses and/or tags to get the address you want, just like if you are using a map website or app.\n\n\n\n\n\n\nTip\n\n\n\nCheck out the list of all the different amenity types available on Open Street Maps! Different amenity types might be different types of vector data, such as a point location or a building footprint polygon.\n\n\n\n# Search for United Tribes Technical College\nuttc_gdf = osm.features_from_address(\n    'United Tribes Technical College, Bismarck, ND, United States',\n    {'amenity': ['college']})\nuttc_gdf\n\n\nuttc_gdf.plot()\n\nWe have a map of the UTTC Campus!\n\n\n\n\n\n\nWarning\n\n\n\nThe Open Street Maps (OSM) database is not always complete. For example, try searching for UTTC with the {'building': True}, and compare it to the map of the UTTC campus on their website. What do you notice?\n\n\n\n\n\nThere are lots of different ways to create maps and plots in Python. Here, we’re going to use a tool called 'hvplot' and 'geoviews' to create an interactive map, including the online 'EsriImagery' tile source basemap.\n\n# Plot UTTC boundary\nuttc_map = uttc_gdf.hvplot(\n    # Givethe map a descriptive title\n    title=\"United Tribes Technical College, Bismarck, ND\",\n    # Add a basemap\n    geo=True, tiles='EsriImagery',\n    # Change the colors\n    fill_color='white', fill_alpha=0.2,\n    line_color='skyblue', line_width=5,\n    # Change the image size\n    frame_width=400, frame_height=400)\n\n# Save the map as a file to put on the web\nhv.save(uttc_map, 'uttc.html')\n\n# Display the map\nuttc_map\n\n\n\n\nIf you are doing this activity on GitHub Codespaces, you will need to download the map you created:\n\nOpen the Folders tab on the left hand side\nRight-click on uttc.html (or whatever you named your file)\nSelect Download...\n\nThis should download your map.\n::: {.content-hidden when-profile=“nb”}\n\n\n\nYou are now ready to upload your map to your portfolio repository and place it in your webpage. Because it is HTML and not an image, you will need to use the following HTML to get it on your page:\n&lt;embed type=\"text/html\" src=\"uttc.html\" width=\"600\" height=\"600\"&gt;\n\n\n\n\n\n\n\nImportant\n\n\n\nMake sure to make the width and height of your embed element larger than the frame_width and frame_height of your plot, or it will get cut off!\n\n\n:::"
  }
]